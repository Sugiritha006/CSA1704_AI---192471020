from collections import deque

# State representation: (M_left, C_left, Boat_side)
# Boat_side = 1 (left), 0 (right)
# Missionaries & Cannibals on the right = total - left

def is_valid(state):
    M_left, C_left, boat = state
    M_right = 3 - M_left
    C_right = 3 - C_left

    # Check valid numbers
    if M_left < 0 or C_left < 0 or M_right < 0 or C_right < 0:
        return False

    # Missionaries eaten? (left side or right side)
    if (M_left > 0 and C_left > M_left) or (M_right > 0 and C_right > M_right):
        return False

    return True


def get_neighbors(state):
    M_left, C_left, boat = state
    moves = [(1,0), (2,0), (0,1), (0,2), (1,1)]  # possible boat moves
    neighbors = []

    for m, c in moves:
        if boat == 1:  # Boat on left -> move people to right
            new_state = (M_left - m, C_left - c, 0)
        else:  # Boat on right -> move people back to left
            new_state = (M_left + m, C_left + c, 1)

        if is_valid(new_state):
            neighbors.append(new_state)

    return neighbors


def bfs(start, goal):
    queue = deque([(start, [start])])
    visited = set()

    while queue:
        state, path = queue.popleft()
        if state == goal:
            return path

        if state in visited:
            continue
        visited.add(state)

        for neighbor in get_neighbors(state):
            queue.append((neighbor, path + [neighbor]))

    return None


if __name__ == "__main__":
    start_state = (3, 3, 1)  # 3 missionaries, 3 cannibals, boat on left
    goal_state = (0, 0, 0)   # all moved to right

    solution = bfs(start_state, goal_state)

    if solution:
        print("Solution found in", len(solution)-1, "moves:")
        for step in solution:
            print(step)
    else:
        print("No solution exists.")
o/p
Solution found in 11 moves:
(3, 3, 1)
(3, 1, 0)
(3, 2, 1)
(3, 0, 0)
(3, 1, 1)
(1, 1, 0)
(2, 2, 1)
(0, 2, 0)
(0, 3, 1)
(0, 1, 0)
(0, 2, 1)
(0, 0, 0)
